# 8강\(by Bookstore3\)

---

이번 8강의 내용은 7강의 마지막 내용의 연장과 IRQ의 처리를 더욱 효율적으로 처리하기 위한 방법으로 나온 Top-Half와 Bottom-Half에 대해서 배우게 될 것이다. 8강을 시작하면서 간단히 복습을 하며 8강의 내용을 진행 할 것이다.

## 8.1 IRQ

---

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0801.png)

그럼 이제 잠시 IRQ 인터럽트가 어떻게 일어나며 그 과정이 어떤식으로 일어났는지 잠시 그림과 함께 알아보자.

먼저 APIC에 여러개의 IRQ 라인이 달려있다. 이 라인들에는 여러개의 장치들이\(이 그림에서는 dev \#1, dev \#2\) 붙어있다. 먼저 이 장치들이 인터럽트를 요청을 하면 그 장치가 붙어있던 m번째 IRQ 라인을 통해 인터럽트를 하게 된다. 그럼 이 인터럽트 요청은 여러개의 IRQ 라인들을 관리하는 APIC\(Advanced Programmable Interrupt Controller\)에게 전달이 된다. 이때, 이 IRQ에서는 한 장치의 인터럽트 요구를 수행중인 것이기 때문에 이 IRQ에 붙어있는 다른 장치들의 인터럽트 요청은 잠시 대기 된다.

이런 전달을 요청받은 APIC은 지금 가장 일을 덜 했던 CPU를 찾아 신호를 보내 이 요청에 반응을 해 줄 것을 요구한다. 만약 CPU i가 이 요청을 받게 되면, CPU i는 요청을 받았다는 것을 인지했다고 하며 ACK 신호를 보내준다. 이런 상태를 IRQPENDING이라고 한다. IRQ\_PENDING이란, CPU가 인지를 했고 그에 따른 ACK\(Acknowledge\) 신호를 보냈지만 아직 커널이 이 인터럽트가 요구하는 일들을 해준 상태가 아니라는 뜻이다.

이제 그럼 CPU i는 실제로 요청이 들어온 인터럽트의 해야 할 일, ISR\(Interrupt Service Routine\)을 누가 실제로 처리를 하게 만들지 정한다. 여기서 CPU i에게 APIC이 요청을 했으니 CPU i가 당연히 해야하는거 아니냐고 물어볼 수도 있다. 물론 만약 m번째 IRQ의 인터럽트 요청이 완전 처음이라 다른 CPU가 IRQ 라인에서 일을 하고 있지 않다면 당연히 CPU i가 일을 처리하러 간다. 본인에게 인터럽트가 온 IRQ에게 가서 IRQ\_INPROGRESS, 즉, 지금 일을 하고 있는 중입니다 라는 신호를, 마치 호텔에서 청소할때 문앞에 거는 싸인처럼 ,문앞에 걸어두고 일을 처리할 것이다.

그러나 만약 CPU i가 인터럽트 요청을 받기전에 또 다른 장치로부터 인터럽트 요청이 있었고 그때의 요청을 CPU j가 맡고 있는 경우가 있을 수도 있다. 만약 그렇다면 CPU i가 들어가서 일을 처리하려는 ISR에 이미 CPU j가 본인이 맡은 일을 처리 중 인 것이다. 이런 경우에 IRQ에 i도 같이 ISR을 따라 가며 일해봤자 어차피 순서대로 ISR을 따라 일을 해야함으로 i와 j가 같이 있다고 해서 일이 빨라지는 것도 아닐 뿐더러 한 IRQ에 두개의 CPU나 붙잡혀 있는 것임으로 매우 비효율적이다.

이런 경우에는 i는 IRQ\_INPROGRESS라는 신호를 IRQ\_PENDING이라는 신호로 바꾸고 돌아간다. 그럼 나중에 CPU j가 일을 다 끝내고 돌아가려 할 때, 이 IRQ\_PENDING을 보고 다른 장치에서 IRQ 요청을 필요로해서 다른 CPU가 왔다 갔었다는 것을 인지하고 다시 한번 ISR을 돌면서 그 일을 처리해준다.

이런 순서에 대한 예시로 호텔의 청소부 상황을 아래에 들어보았다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0802.png)

> 조금 더 쉬운 비유를 들자면 호텔 101호에 청소 요청이 들어왔다고 생각해보자. 이때, 청소의 확인 순서는 반드시 현관\(1\), 화장실\(2\), 침실\(3\) 순으로 확인을 해야하며 청소를 하러 들어갔을때에는 문앞에 **표지판**에 "청소중"이라는 문구를 쓰고 들어가 청소를 해야한다는 규칙이 있다고 생각해보자.
>
> 지금 상황은 고객님께서 침실\(3\)을 청소하기를 부탁한 상황이다. 물론 이런 요청을 처리하기 위해서는 위의 규칙 순서대로 확인을 하고 침실을 확인하는 순서에서 침실 청소를 해야할 것이다. 절대로 바로 들어가자마자 침실을 청소하기 시작해서는 안된다. 이런 고객님의 요청은 데스크를 통해 요청되어 지고, 그럼 데스크에서 청소부에게 일을 시킨다.
>
> 여기서 일을 매우 효율적으로 처리하는 i 번째 청소부가 와서 이 방의 침실을 청소하러 왔다고 생각해보자. 먼저 청소부는 문 앞에 표지판에 청소중이라는 문구가 있는지 확인을 한다. 만약 문구가 "청소 바람"이라면 문구를 "청소중"이라고 바꾸고 i는 방에 들어가 순서대로 방을 확인하며 자신이 맡은 구역을 청소 할 것이다.
>
> 그러나 만약 이미 "청소중"이라는 문구가 있다면, 이 방의 고객님께서 아마 침실이 아닌 현관\(1\)이나 화장실\(2\)을 청소해달라는 요청을 전에 했었을 상황이다. 청소중이라는 문구가 있다면, 지금 방안에서는 다른 청소부, j가 현관\(1\), 화장실\(2\), 침실\(3\)을 보며 본인에게 요청이 온 청소 구역\(여기서는 현관\(1\)이라고 가정하자\)을 청소하고 있을 것이다.
>
> 만약 이렇게 j가 안에서 청소를 하고 있다면 i는 어차피 침실\(3\)을 청소하려면 현관\(1\)을 확인하고, 화장실\(2\) 그리고 나서 침실\(3\)을 확인하는 순서로 일을 진행해야 한다. 즉, j가 현관\(1\)에 딱 막고 서서 청소를 하고 있는 중이라면 현관을 건너뛰고 바로 침실을 갈 수 없기 때문에 청소를 하러 들어간다해도 어차피 j가 한바퀴 도는 시간이랑 비슷하게 청소가 끝날 것이다. 즉, i는 쓸데없이 j가 일을 끝내는 것을 기다리다가 마지막 본인이 맡은 구역인 침실\(3\)을 하나 청소하고 나오게 될 것이란 뜻이다.
>
> 이는 i에게 있어서는 어마어마한 시간 낭비이기 때문에, 문을 열고 들어가 멍하니 기다리기보다 i는 문 앞에 있는 표지판의 내용을 "청소중"에서 "청소 바람"으로 바꾸고 돌아가서 다른 일을 한다. 그럼 방 안에서 일을 처리하고 있던 j는 청소를 다 끝내고 나오면서 표지판을 쳐다보는데 "청소중"에서 "청소 바람"으로 바뀐것을 알게된다. 즉, 이말은 j가 청소를 하던 도중 본인이 맡은 구역 이외에 다른 곳도 청소가 필요해서 다른 청소부가 왔다가 j가 있는 것을 보고, j에게 청소가 다 끝나면 다시 한번 방을 확인 하라고 한 것이랑 똑같은 의미가 된다.
>
> 그럼 이제 j는 표지판을 다시 "청소중"이라고 바꾼 뒤, 다시 한번 방안에 들어가 현관-&gt;화장실-&gt;침실 순으로 확인을 하고, 아까 i에게 요청이 들어왔던 침실 청소를 해달라는 것을 발견하게 되고 침실 청소를 j가 끝을 내고 나오게 된다. 이때 표지판이 다행히 j가 다시 들어가면서 바꿨던 "청소중"의 상태였다면 다행히 이 방에서 청소 요청이 들어온 구역은 더 이상 없다는 뜻이고, j는 무사히 돌아가게 된다.

이 모든 상황을 3가지로 나눠서 정리를 하면 아래 그림과 같게 된다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0803.png)

CPU i 한테 m번째의 IRQ가 들어왔을때의 상황이다.

1. m번째의 IRQ에 어떤 CPU도 일을 하고 있지 않은 상황이다.  
   이 경우엔 CPU i가 일을 처리한다.

2. 다른 CPU인 k가 이미 m번째 IRQ 라인의 핸들러에 들어가 일을 처리하고 있다.  
   CPU i는 어떤 일도 하지 않는다. 그저 m번째 IRQ의 상태를 IRQ\_PENDING 이라고 바꾸고 돌아간다.

3. CPU k가 m번째 IRQ의 핸들러를 통해 일을 다 처리했을 시  
   ISR을 떠나기 전에 m번째 IRQ의 상태를 확인한다. 만약 아까 위의 2번의 상황이 있어서 IRQ\_PENDING의 상태가 되어 있다면 k가 일을 하는 동안에 똑같은 ISR에서 일이 있어서 다른 CPU가 왔다가 갔다는 의미가 된다. 이걸 보고 k는 다시 한번 ISR을 따라가며 일을 처리한다.

## 8.2 Race Condition

---

위의 IRQ 과정을 보면서 알아야 할 점은 IRQ 하는 과정은 매우 민폐를 끼치는 과정이라는 것이다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0804.png)

일단 먼저 장치가 인터럽트 요청을 하면 CPU로 부터 ACK를 받기까지 해당 IRQ가 붙어있던 APIC는 다른 장치들의 인터럽트 요청은 받을 수 없다. 이때 다른 IRQ 라인들은 멍하니 기다려야한다.

또한 이렇게 요청을 받아서 CPU가 일을 처리하려고 와서 IRQ 의 상태를 확인해서 먼저 들어가 있는 CPU가 있는지 없는지 확인하고 있다면 IRQ\_PENDING으로 바꾸고 아니라면 IRQ\_INPROGRESS로 상태를 바꾸고 ISR로 들어갈때까지 이 IRQ에 여러 CPU가 와서 값을 막 바꾸면 안되기 때문에 spin\_lock\(\)을 통해 다른 CPU가 irq\_desc\[m\]에 들어올 수 없게 락을 걸어버린다.

이처럼 한번 IRQ를 하게 되면 APIC, 다른 CPU등 한테 어마어마한 민폐를 끼치게 되기 때문에 처음 IRQ 요청을 해서 ISR에 들어가는 그 시간은 정말 최대한 짧게 잡아야한다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0805.png)

> do\_IRQ\(\) 하면서 발생하는 다양한 상황을 설명한 그림이다. 보다시피 PIC와 CPU의 접근등이 제한되어있는 구역이 있는 만큼 매우 빠르게 진행이 되어야 하는 구역이다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0806.png)

이러한 과정을 7장에서 봤던 코드를 통해 구역을 나누게 된다면, 노란색으로 표시된 부분이 아직 ISR에 들어가지 못한 매우 중요하고 빠르게 일어나야 하는 부분이다. 그에 반면에 오른쪽 아래에 있는 handler 구역은 ISR에 들어가 순서대로 따라가면서 일을 처리하고 있으며, 다른 CPU나 APIC의 제한은 이미 다 풀려진 상태인 만큼 어느정도 여유를 가지고 일을 처리해도 되는 부분이다.

그러나 이런 여유롭게 처리를 할 수 있는 구역에서 처리해야 하는 일의 양이 어마어마하게 큰 일이라면 어떻게 해야할까. 하나의 인터럽트의 어마어마한 일을 처리해야하는 ISR의 일이 다 끝날때까지 기다려야 하는 것일까. 이는 매우 비효율적일 것이다.

이럴때 우리는 위 코드의 구역을 두가지 영역으로 먼저 나눈다. do\_IRQ\(\)가 들어가 다른 APIC이나 CPU의 인터럽트가 락이 걸려 빠르게 진행을 해 줘야 하는 부분을 **Critical Top-Half**라고 부른다. 또 이런 모든 제한들이 풀려 어느정도 여유가 있는 ISR안에 들어온 것을 **Non-Critical Top-Half**라고 부른다. 특히 여기서 Critical Top-Half는 간단하게 진행할 수 있는 일의 양이나, 긴급하게 일을 처리해야 할 때, 인터럽트를 락을 걸고 일을 급하게 진행이 되는 영역을 뜻한다.

그리고 이제 ISR에 들어와서 Non-Critical Top-Half 영역에서는, 지금 요청이 들어온 ISR의 일을 처리하려고 보니 너무 일의 양이 커서 시간을 다 빼앗길 것 같으니 여기서 **Bottom-Half**가 필요로 하다, 즉 이 장치에 대한 일은 지금 다 못해주고 나중에 계속 와서 중간중간 해 줘야 한다고 Bottom-Half를 스케쥴 하고 나간다. 이때, 이 Bottom-Half의 일을 처리해주기 위해** do\_softirp\(\)**라는 함수에 의해 호출이 된다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0807.png)

이러한 Top-Half와 Bottom-Half의 예시로 네트워크의 경우를 들 수 있다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0808.png)

만약 네트워크 인터페이스 카드로\(NIC\) 어떠한 정보가 날라와서 CPU에게 이 정보들을 읽어달라고 NIC가 인터럽트를 요청했다고 가정하자. 그럼 먼저 PIC에게 인터럽트 요청이 갈 것이고, 그럼 CPU를 선출한 뒤 do\_IRQ\(\)를 통해 ACK 신호를 보내 줄 것이다. 그럼 IRQ\_PENDING의 신호로 바뀔 것이다. 이때 네트워크에서 날라온 데이터의 양이 방대함으로 바로 처리를 해주지 않고, 추후에 처리를 해주기 위해 먼저 NIC로부터 packet에 들어있는 내용을 메모리로 옮길 것이다. 그리고 bottom-half required 비트를 켜놓고 빠져나온다. 그럼 나중에 do\_softirp\(\)가 호출이 되면 그때 IP프로토콜과 TCP 프로토콜에 의해 packet을 socket으로 이동시키고 일을 처리할 것이다.

![](/Users/wisecow/Dropbox/Mac/gitbook/Linux-Kernel-Lecture-Note/images/lk_0809.png)

이처럼 용량이 큰 ISR의 일을 처리하기 위해 Top-Half와 Bottom-Half로 일 처리 기간을 나누어 처리를 한다. 우리는 처리를 하러 올 때 do\_softirq\(\)라는 것을 통해 온다는 것을 배웠는데 이 함수가 호출되는 경우는, IRQ\(\)에서 돌아오고 나서, 우선순위가 낮은 커널 스레드가 부를때, 아니면 다른 코드에 의해서 불러지는 경우가 있다.  이처럼 Top, Bottom Half 처리 방식은 일의 처리 속도 뿐만 아니라, 용량이 큰 일을 처리함에 있어서도 매우 효율적인 방법으로 처리를 해준다는 것을 알 수 있다.

## 8강 마감

---

이번 강의를 통해서 IRQ\_INPROGRESS 상태가 되어있을때 후에 들어온 CPU가 어떻게 처리를 하는지, 그리고 용량이 큰 ISR을 처리하는 방법에 대해 배웠다.

